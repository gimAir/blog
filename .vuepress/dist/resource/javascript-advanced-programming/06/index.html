<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>6 面向对象的程序设计 | Blog</title>
    <meta name="description" content="笔记整理、资料记录">
    
    
    <link rel="preload" href="/assets/css/0.styles.d69d1c49.css" as="style"><link rel="preload" href="/assets/js/app.e304fcc0.js" as="script"><link rel="preload" href="/assets/js/2.288486c1.js" as="script"><link rel="preload" href="/assets/js/14.e911768a.js" as="script"><link rel="prefetch" href="/assets/js/10.12bfeffb.js"><link rel="prefetch" href="/assets/js/11.ef69e21a.js"><link rel="prefetch" href="/assets/js/12.5942c6ab.js"><link rel="prefetch" href="/assets/js/13.ee5d1fb5.js"><link rel="prefetch" href="/assets/js/15.e2e537fa.js"><link rel="prefetch" href="/assets/js/16.eb296e15.js"><link rel="prefetch" href="/assets/js/17.a3c1c608.js"><link rel="prefetch" href="/assets/js/18.9931c1b5.js"><link rel="prefetch" href="/assets/js/3.bf113cc3.js"><link rel="prefetch" href="/assets/js/4.6ed8f1dd.js"><link rel="prefetch" href="/assets/js/5.074e55d4.js"><link rel="prefetch" href="/assets/js/6.4ac7b85e.js"><link rel="prefetch" href="/assets/js/7.92f63520.js"><link rel="prefetch" href="/assets/js/8.4db4a8cc.js"><link rel="prefetch" href="/assets/js/9.09927fc1.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d69d1c49.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/note/" class="nav-link">笔记</a></div><div class="nav-item"><a href="/resource/" class="nav-link router-link-active">资料</a></div><div class="nav-item"><a href="https://github.com/gimAir/javascript" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/note/" class="nav-link">笔记</a></div><div class="nav-item"><a href="/resource/" class="nav-link router-link-active">资料</a></div><div class="nav-item"><a href="https://github.com/gimAir/javascript" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><a href="/resource/javascript-advanced-programming/" class="sidebar-heading clickable router-link-active open"><span>Javascript高级程序设计</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/resource/javascript-advanced-programming/04/" class="sidebar-link">4 变量、作用域和内存问题</a></li><li><a href="/resource/javascript-advanced-programming/05/" class="sidebar-link">5 引用类型</a></li><li><a href="/resource/javascript-advanced-programming/06/" class="active sidebar-link">6 面向对象的程序设计</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/resource/javascript-advanced-programming/06/#_6-1-理解对象" class="sidebar-link">6.1 理解对象</a></li><li class="sidebar-sub-header"><a href="/resource/javascript-advanced-programming/06/#_6-2-创建对象" class="sidebar-link">6.2 创建对象</a></li><li class="sidebar-sub-header"><a href="/resource/javascript-advanced-programming/06/#_6-3-继承" class="sidebar-link">6.3 继承</a></li><li class="sidebar-sub-header"><a href="/resource/javascript-advanced-programming/06/#_6-4-总结-faq" class="sidebar-link">6.4 总结 &amp; FAQ</a></li></ul></li><li><a href="/resource/javascript-advanced-programming/07/" class="sidebar-link">7 函数表达式</a></li><li><a href="/resource/javascript-advanced-programming/13/" class="sidebar-link">13 事件</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_6-面向对象的程序设计"><a href="#_6-面向对象的程序设计" aria-hidden="true" class="header-anchor">#</a> 6 面向对象的程序设计</h1> <h2 id="_6-1-理解对象"><a href="#_6-1-理解对象" aria-hidden="true" class="header-anchor">#</a> 6.1 理解对象</h2> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/**
* Object构造函数
*/</span>
<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// let person = {}; 这是新建对象的语法糖</span>

person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Nicholas'</span><span class="token punctuation">;</span>
person<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">29</span><span class="token punctuation">;</span>
person<span class="token punctuation">.</span>job <span class="token operator">=</span> <span class="token string">'Software Engineer'</span><span class="token punctuation">;</span>

person<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 会被解析为 person.name;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/**
 * 字面量语法
 */</span>
<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token punctuation">:</span> <span class="token string">'Nicholas'</span><span class="token punctuation">,</span>
    age<span class="token punctuation">:</span> <span class="token number">29</span><span class="token punctuation">,</span>
    job<span class="token punctuation">:</span> <span class="token string">'Software Engineer'</span><span class="token punctuation">,</span>
    <span class="token function-variable function">sayName</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 会被解析为 person.name;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="_6-1-1-属性类型"><a href="#_6-1-1-属性类型" aria-hidden="true" class="header-anchor">#</a> 6.1.1 属性类型</h3> <p>ECMAScript中有两种属性： <strong>数据属性</strong> 和 <strong>访问器属性</strong> 。</p> <h4 id="数据属性"><a href="#数据属性" aria-hidden="true" class="header-anchor">#</a> 数据属性</h4> <p>数据属性有4个描述其行为的特性;</p> <ul><li>[[Configurable]]：表示能否通过delete删除属性从而重新定义属性、能否修改属性的特性，或者能否把属性修改为访问器属性。（直接在对象上定义的属性，该特性默认值为true）。</li> <li>[[Enumerable]]：表示能否通过for-in循环返回属性。（直接在对象上定义的属性，该特性默认值为true）。</li> <li>[[Writable]]：表示能否修改属性的值。（直接在对象上定义的属性，该特性默认值为true）。</li> <li>[[Value]]：包含这个属性的数据值。读取属性值的时候从这个位置读；写入属性值的时候把新值保存在这个位置。（该特性默认值为undefined）。</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token punctuation">:</span> <span class="token string">'Nicholas'</span>
<span class="token punctuation">}</span>
</code></pre></div><p>创建了一个名为name的属性，其值为'Nicholas'；也就是，[[Value]]特性将被设置为'Nicholas'。</p> <p>既然属性有默认特性值，那么它也一定可以被修改，ECMAScript 5（以下简称ES5）就为提供了 <strong>Object.defineProperty()</strong> 这个方法包含三个参数： 属性所在对象、属性的名字和一个描述符对象（该对象的属性必须为：configuration、enumerable、writable、value）。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
   writable<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
   value<span class="token punctuation">:</span> <span class="token string">'Nicholas'</span> 
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'Nicholas'</span>
person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Barry'</span><span class="token punctuation">;</span>    <span class="token comment">// 非严格模式下，此操作忽略，执行下一行代码；严格模式下，该操作会导致抛出错误。</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 非严格模式下打印 'Nicholas'</span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
   configurable<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
   value<span class="token punctuation">:</span> <span class="token string">'Nicholas'</span> 
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 情况一</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'Nicholas'</span>
<span class="token keyword">delete</span> person<span class="token punctuation">.</span>name<span class="token punctuation">;</span>       <span class="token comment">// 非严格模式下，此操作忽略，执行下一行代码；严格模式下，该操作会导致抛出错误。</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 非严格模式下打印 'Nicholas'</span>

<span class="token comment">// 情况二</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
   configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
   value<span class="token punctuation">:</span> <span class="token string">'Nicholas'</span> 
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 抛出错误，一旦configurable设置为false，就不能再更改回去；同时再调用Object.defineProperty()方法只能修改writable特性，否则会抛出错误。</span>
</code></pre></div><p>在调用Object.defineProperty()方法创建一个新属性时，如果不指定，configuration、enumerable、writable特性的默认值都会为false。</p> <p><em>由于实现不彻底，IE8不建议使用Object.defineProperty()方法。</em></p> <h4 id="访问器属性"><a href="#访问器属性" aria-hidden="true" class="header-anchor">#</a> 访问器属性</h4> <p>访问器属性不包含数据值；它们包含一对getter和setter函数（这两个函数不是必须的）；访问器属性拥有4个特性：</p> <ul><li>[[Configurable]]：表示能否通过delete删除属性从而重新定义属性、能否修改属性的特性，或者能否把属性修改为访问器属性。（直接在对象上定义的属性，该特性默认值为true）。</li> <li>[[Enumerable]]：表示能否通过for-in循环返回属性。（直接在对象上定义的属性，该特性默认值为true）。</li> <li>[[Get]]：在读取属性时调用的函数。（默认值为undefined）</li> <li>[[Set]]：在写入属性时调用的函数。（默认值为undefined）</li></ul> <p>访问器属性也不能直接定义，必须使用Object.defineProperty()方法。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> book <span class="token operator">=</span> <span class="token punctuation">{</span>
    _year<span class="token punctuation">:</span> <span class="token number">2004</span><span class="token punctuation">,</span>        <span class="token comment">// 添加下划线，表示只能通过对象方法访问的属性。</span>
    edition<span class="token punctuation">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>book<span class="token punctuation">,</span> <span class="token string">'year'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_year<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">newValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">&gt;</span> <span class="token number">2004</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>_year <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>edition <span class="token operator">+=</span> newValue <span class="token operator">-</span> <span class="token number">2004</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

book<span class="token punctuation">.</span>year <span class="token operator">=</span> <span class="token number">2005</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>book<span class="token punctuation">.</span>year<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre></div><p>getter和setter可以不同时设定，单独设置getter（或setter）意味着属性不能写（或读），尝试写入（或读取）属性会被忽略（或返回undefined），在严格模式下都会抛出错误。</p> <h3 id="_6-1-2-定义多个属性"><a href="#_6-1-2-定义多个属性" aria-hidden="true" class="header-anchor">#</a> 6.1.2 定义多个属性</h3> <p>当定义多个属性时，ES5又为开发者提供了一个 <strong>Object.defineProperties()方法</strong>，该方法接收两个参数：要添加或修改其属性的对象、对象属性要与第一个对象中要添加或修改的属性一一对应。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> book <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

Object<span class="token punctuation">.</span><span class="token function">defineProperties</span><span class="token punctuation">(</span>book<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    _year<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        writable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        value<span class="token punctuation">:</span> <span class="token number">2004</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    edition<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        writable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        value<span class="token punctuation">:</span> <span class="token number">1</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    year<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        <span class="token function-variable function">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_year<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function-variable function">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">&gt;</span> <span class="token number">2004</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>_year <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>edition <span class="token operator">+=</span> newValue <span class="token operator">-</span> <span class="token number">2004</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>以上代码实现了在book对象中定义了两个数据属性：_year和edition，一个访问器属性：year。</p> <h3 id="_6-1-3-读取属性的特性"><a href="#_6-1-3-读取属性的特性" aria-hidden="true" class="header-anchor">#</a> 6.1.3 读取属性的特性</h3> <p>ES5提供了一个 <strong>Object.getOwnPropertyDescriptor()</strong> 方法，可以取得给定属性的描述符。该方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值为一个对象。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> book <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

Object<span class="token punctuation">.</span><span class="token function">defineProperties</span><span class="token punctuation">(</span>book<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    _year<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        writable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        value<span class="token punctuation">:</span> <span class="token number">2004</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    edition<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        writable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        value<span class="token punctuation">:</span> <span class="token number">1</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    year<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        <span class="token function-variable function">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_year<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function-variable function">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">&gt;</span> <span class="token number">2004</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>_year <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>edition <span class="token operator">+=</span> newValue <span class="token operator">-</span> <span class="token number">2004</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> descriptor <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>book<span class="token punctuation">,</span> <span class="token string">'_year'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2004</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">.</span>configurable<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> descriptor<span class="token punctuation">.</span>get<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// undefined</span>

descriptor <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>book<span class="token punctuation">,</span> <span class="token string">'year'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// undefined</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">.</span>enumerable<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> descriptor<span class="token punctuation">.</span>get<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 'function'</span>
</code></pre></div><p>在JavaScript中，可以针对任何对象——包括DOM和BOM对象，使用Object.getOwnPropertyDescriptor()方法。兼容浏览器有IE9+和现代浏览器。</p> <h2 id="_6-2-创建对象"><a href="#_6-2-创建对象" aria-hidden="true" class="header-anchor">#</a> 6.2 创建对象</h2> <p>传统的Object构造函数和对象字面量虽然都可以创建单个对象，但是这些方式有个明显缺点：使用同一个接口创建很多对象，产生大量重复代码。 <strong>工厂模式</strong> 出现就是为了解决这个问题。</p> <h3 id="_6-2-1-工厂模式"><a href="#_6-2-1-工厂模式" aria-hidden="true" class="header-anchor">#</a> 6.2.1 工厂模式</h3> <p>因为无法在ECMAScript中创建类，所以用函数来封装以特定接口创建对象的细节。如：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age <span class="token punctuation">,</span>job</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  obj<span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  obj<span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  obj<span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>
  obj<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  
  <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token string">'Nicholas'</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token string">'Software Engineer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token string">'Barry'</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">,</span> <span class="token string">'Doctor'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>工厂函数虽然解决了创建对个相似对象的问题，但是没有解决如何识别对象类型的问题。 <strong>构造函数模式</strong> 解决了这个问题。</p> <h3 id="_6-2-2-构造函数模式"><a href="#_6-2-2-构造函数模式" aria-hidden="true" class="header-anchor">#</a> 6.2.2 构造函数模式</h3> <p>ECMAScript中的构造函数可以用来创建特定类型对象，比如Array和Object这样的原生构造函数；也可以创建自定义的构造函数，从而自定义对象类型的属性和方法。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Nicholas'</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token string">'Software Engineer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Barry'</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">,</span> <span class="token string">'Doctor'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Person()函数和createPerson()函数存在以下差异：</p> <ul><li>没有显示创建对象；</li> <li>直接将属性和方法赋给了this对象；</li> <li>没有return语句；</li></ul> <p>在创建Person实例时，必须使用new操作符，这种方式调用构造函数实际上经过以下过程：</p> <ol><li>创建一个新对象；</li> <li>将构造函数的 <strong>作用域</strong> 赋给新对象（this就指向了新对象）；</li> <li>执行构造函数中的代码（为新对象添加属性和方法）；</li> <li>返回新对象；</li></ol> <p>Person的两个不同实例对象p1、p2都包含着一个constructor属性，该属性最初是用来标识对象类型的。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>但是检测对象类型， <strong>instanceof</strong> 操作符更可靠一些。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1 <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1 <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p2 <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p2 <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true</span>

<span class="token comment">// p1、p2都是Person的实例，而Person又是Object的实例，所有对象均继承自Object。</span>
</code></pre></div><h4 id="_6-2-2-1-将构造函数当作函数"><a href="#_6-2-2-1-将构造函数当作函数" aria-hidden="true" class="header-anchor">#</a> 6.2.2.1 将构造函数当作函数</h4> <p>任何函数，只要通过 new 操作符来调用，那它就可以作为构造函数；而任何函数，如果不通过 new 操作符来调用，那么它跟普通函数没什么区别。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 当做构造函数使用</span>
<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Nicholas'</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token string">'Software Engineer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
person<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// Nicholas</span>

<span class="token comment">// 作为普通函数调用</span>
<span class="token function">Person</span><span class="token punctuation">(</span><span class="token string">'Greg'</span><span class="token punctuation">,</span> <span class="token number">27</span> <span class="token punctuation">,</span> <span class="token string">'Doctor'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 添加到全局window对象</span>
window<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// Greg</span>

<span class="token comment">// 在另一个对象的作用域中调用</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Person</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'Kristen'</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token string">'Nurse'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// Kristen</span>
</code></pre></div><h4 id="_6-2-2-2-构造函数的问题"><a href="#_6-2-2-2-构造函数的问题" aria-hidden="true" class="header-anchor">#</a> 6.2.2.2 构造函数的问题</h4> <p>使用构造函数的主要问题就是，每个方法都要在每个实例上重新创建一遍。例如之前例子中，p1、p2都有一个名为sayName()的方法，但是两个方法不是同一个Function的实例。（ECMAScript中的函数是对象！！！）</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...略</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token string">'console.log(this.name)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 等价于 this.sayName: function() {}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>以这种方式创建，会导致不同的作用域和标识符解析，因此p1和p1的同名函数实际上是不相等的</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>sayName <span class="token operator">===</span> p2<span class="token punctuation">.</span>sayName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre></div><p>为了解决这个问题，我们可以：通过把函数定义转移到函数外部来解决。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...略</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sayName <span class="token operator">=</span> sayName<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样一来，我们将 sayName 属性设置成了等于全局的 sayName 函数，p1和p2对象就共享了在全局作用域中定义的sayName()函数。但新问题又出现了：</p> <ol><li>在全局作用域中定义的函数实际上只能被某个对象调用</li> <li>而且如果对象需要定义很多方法，那么就需要定义很多歌全局函数，这样就没有封装性可言了。</li></ol> <p>好在出现了 原型模式 来解决上述问题。</p> <h3 id="_6-2-3-原型模式"><a href="#_6-2-3-原型模式" aria-hidden="true" class="header-anchor">#</a> 6.2.3 原型模式</h3> <p><strong>我们创建的每一个函数都有一个 prototype（原型）属性</strong> ，指向的是一个包含可以由特定类型的所有实例共享的属性和方法的对象，换言之： prototype 指向的是通过调用构造函数创建的实例对象的原型对象。。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
<span class="token punctuation">}</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Nicholas'</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">29</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>job <span class="token operator">=</span> <span class="token string">'Software Engineer'</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// Nicholas</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// Nicholas</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>sayName <span class="token operator">===</span> p2<span class="token punctuation">.</span>sayName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><h4 id="_6-2-3-1-什么是原型对象？"><a href="#_6-2-3-1-什么是原型对象？" aria-hidden="true" class="header-anchor">#</a> 6.2.3.1 什么是原型对象？</h4> <p>只要创建了一个新函数，那么就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性是一个指向prototype 属性所在函数的指针。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><ul><li>创建自定义构造函数后，其原型对象默认只会取得 constructor 属性，至于其他方法均继承自Object</li> <li>调用构造函数创建新实例后，该实例内部将包含一个指针指向构造函数的原型，ES5中该指针叫 [[prototype]]，Firefox、Chrome和Safari都支持 <strong>proto</strong> 属性。</li> <li>重要的一点就是：这个连接存在于实例与构造函数的原型对象之间，而不存在于实例与构造函数之间。</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// Person构造函数、Person的原型属性和Person的实例之间的关系</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p>我们可以用 <strong>isPrototypeOf()</strong> 方法来确定对象之间是否存在原型的关系，其本质就是：如果 [[prototype]] 指向了调用 isPrototypeOf() 方法的对象（Person.prototype），那么该方法就会返回 true。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true</span>
</code></pre></div><p>ES5还提供了一个方法 <strong>Object.getPrototypeOf()</strong> ，该方法分会 [[prototype]] 的值，使用 Object.getPrototypeOf() 方法也可以方便的获取一个对象的原型。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 'Nicholas'</span>
</code></pre></div><p>我们可以通过实例访问保存在原型中得值，但是不能通过实例重写原型中的值，当实例中的属性与原型中属性同名了，那么该属性就会屏蔽（不是替换也不是覆盖，而是阻止我们访问原型中的属性，但原型中的属性依然存在，哪怕值为null）原型中的属性。不过，我们也可以通过 delete 操作符完全删除实例中的属性，从而我们又可以重新访问原型中的属性。<br>
使用 <strong>hasOwnProperty()</strong> 方法可以检测一个属性是存在于实例中还是原型中，返回true表示访问的是实例属性。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Nicholas'</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// 'Nicholas' 来自原型</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false，此时访问的是原型属性</span>

p1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Greg'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// 'Greg' 来自实例</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true，此时访问的是实例属性</span>

<span class="token keyword">delete</span> p1<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// 'Nicholas' 来自原型</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false，此时访问的是原型属性</span>
</code></pre></div><blockquote><p>ES5的 Object.getOwnPropertyDescriptor() 方法只能用于实例属性，想要取得原型属性的描述符，必须直接在原型对象上调用 Object.getOwnPropertyDescriptor() 方法。</p></blockquote> <h4 id="_6-2-3-2-原型与in操作符"><a href="#_6-2-3-2-原型与in操作符" aria-hidden="true" class="header-anchor">#</a> 6.2.3.2 原型与in操作符</h4> <p>两种使用方式：</p> <ul><li>单独使用 <strong>in</strong> （无论该属性存在于实例中还是原型对象中，in 操作符会在对象通过对象能够访问给定属性时返回 true）。</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Nicholas'</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'Nicholas' 来自原型</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false，此时访问的是原型属性</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'name'</span> <span class="token keyword">in</span> p1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

p1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Greg'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'Greg' 来自实例</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true，此时访问的是实例属性</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'name'</span> <span class="token keyword">in</span> p1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

<span class="token keyword">delete</span> p1<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'Nicholas' 来自原型</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false，此时访问的是原型属性</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'name'</span> <span class="token keyword">in</span> p1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p>同时使用 hasOwnPrototype() 方法和 in 操作符，就可以确定该属性到底存在于对象中还是原型中。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">hasPrototypeProperty</span><span class="token punctuation">(</span><span class="token parameter">object<span class="token punctuation">,</span> name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token operator">!</span>Object<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>name <span class="token keyword">in</span> object<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><strong>for-in</strong> 循环中使用（返回的是所有能够通过对象访问的、可枚举的属性，既包括存在于实例中的属性也包括存在于原型中的属性，即使是不可枚举属性[[enumerable]]设置为false，也能被返回）。</li></ul> <p>在IE8以及更早的版本中出现一个bug，即可枚举属性[[enumerable]]设置为false的实例属性不会出现在 for-in 循环中。该bug会影响默认不可枚举的所有属性和方法，包括： <strong>hasOwnProperty()</strong>、<strong>propertyIsEnumerable()</strong>、<strong>toLocaleString()</strong>、<strong>toString()</strong> 和 <strong>valueOf()</strong> 。ES5也将 constructor 和 prototype 属性的 [[enumerable]] 特性设置为false。</p> <p>想要取得所有可枚举的实例属性，可以使用ES 的 <strong>Object.keys()</strong> 方法。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Nicholas'</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">29</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>job <span class="token operator">=</span> <span class="token string">'Software Engineer'</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>keys<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'name, age, job, sayName'</span>

<span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Rob'</span><span class="token punctuation">;</span>
p1<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">31</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> p1Keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1Keys<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'name, age'</span>
</code></pre></div><p>如果你想得到所有实例属性，不管是否可枚举， 可以使用 <strong>Object.getOwnPropertyNames()</strong> 方法。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyNames</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>keys<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'constructor, name, age, job, sayName'</span>
</code></pre></div><h4 id="_6-2-3-3-更简单的原型语法"><a href="#_6-2-3-3-更简单的原型语法" aria-hidden="true" class="header-anchor">#</a> 6.2.3.3 更简单的原型语法</h4> <p>使用字面量方式来写原型对象：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token punctuation">:</span> <span class="token string">'Nicholas'</span><span class="token punctuation">,</span>
    age<span class="token punctuation">:</span> <span class="token number">29</span><span class="token punctuation">,</span>
    job<span class="token punctuation">:</span> <span class="token string">'Software Engineer'</span><span class="token punctuation">,</span>
    <span class="token function-variable function">sayName</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>虽然以这种方式写更简便了，但是随之也出现了一个问题： constructor 属性不在指向 Person 了。</p> <blockquote><p>原因解释：当我们使用字面量创建时，Person.prototype = {} 等同于 Person.prototype = new Object() ，这里我们完全重写了默认的 prototype 对象，因此 constructor 属性也就变成了新对象的 constructor属性（指向 Object 构造函数），不再指向 Person 函数。尽管 instanceof 操作符还能返回正确结果，但是 constructor 已经无法确定对象的类型了。</p></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1 <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1 <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p>解决办法：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token comment">// 解决方案一</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
    constructor<span class="token punctuation">:</span> Person<span class="token punctuation">,</span> <span class="token comment">// 手动将 constructor 指回 Person，但是这样 [[Enumerable]] 会被设置为true，默认原生的 constructor 属性是不可被枚举的</span>
    name<span class="token punctuation">:</span> <span class="token string">'Nicholas'</span><span class="token punctuation">,</span>
    age<span class="token punctuation">:</span> <span class="token number">29</span><span class="token punctuation">,</span>
    job<span class="token punctuation">:</span> <span class="token string">'Software Engineer'</span><span class="token punctuation">,</span>
    <span class="token function-variable function">sayName</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 解决方案二（最佳）</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token string">'constructor'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    enumerable<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    value<span class="token punctuation">:</span> Person
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="_6-2-3-4-原型的动态性"><a href="#_6-2-3-4-原型的动态性" aria-hidden="true" class="header-anchor">#</a> 6.2.3.4 原型的动态性</h4> <p>由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来——即使是先创建了实例后修改了原型也照样如此。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayHi</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hi'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
p1<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'Hi'</span>
</code></pre></div><p>即使实例p1是在添加新方法之前创建的，但他任然可以访问这个新方法。其原因是归结为实例与原型之间的松散型连接关系：当我们调用 p1.sayHi() 时，首先会在实例中搜索 sayHi() 方法，当实例中查找不到时，就会去原型中查找。因为实例和原型之间的连接只不过是一个指针，而非一个副本，因此就可以在原型中找到新的 sayHi 属性并返回保存在那里的函数。</p> <p>但是如果是重写整个原型对象，那么情况就不一样了：构造函数时会为实例添加一个指向最初原型的 [[prototype]] 指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。</p> <p><strong>切记：实例中的指针仅指向原型，而不指向构造函数。</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
    constructor<span class="token punctuation">:</span> Person<span class="token punctuation">,</span>
    name<span class="token punctuation">:</span> <span class="token string">'Nicholas'</span><span class="token punctuation">,</span>
    age<span class="token punctuation">:</span> <span class="token number">29</span><span class="token punctuation">,</span>
    job<span class="token punctuation">:</span> <span class="token string">'Software Engineer'</span><span class="token punctuation">,</span>
    <span class="token function-variable function">sayName</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

p1<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error，因为此时 p1 指向的原型中不包含以该名字命名的属性。</span>
</code></pre></div><h4 id="_6-2-3-5-原生对象的原型"><a href="#_6-2-3-5-原生对象的原型" aria-hidden="true" class="header-anchor">#</a> 6.2.3.5 原生对象的原型</h4> <p>原型模式的重要性不仅体现在创建自定义类型方面，原生的引用类型也采用这种模式。所有的原生引用类型（Array、Object、String等等）都在其构造函数的原型上定义了方法。例如：</p> <ul><li>Array.prototype 中可以找到 sort() 方法；</li> <li>在String.prototype 中可以找到 subString() 方法；</li></ul> <blockquote><p>尽管可以这么做，但是不推荐在产品化的程序中修改原生对象的原型。因为如果某个实现中缺少某个方法，就在原生对象的原型中添加这个方法，那么当另一个支持该方法的实现中运行代码时，就有可能会导致命名冲突。也可能会意外重写该方法。</p></blockquote> <h4 id="_6-2-3-6-原型对象的问题"><a href="#_6-2-3-6-原型对象的问题" aria-hidden="true" class="header-anchor">#</a> 6.2.3.6 原型对象的问题</h4> <ul><li>因为它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下取值都相同，会带来一定的不便；</li> <li>原型最大的问题就是由其共享的本性所导致的；</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  constructor<span class="token punctuation">:</span> Person<span class="token punctuation">,</span>
  name<span class="token punctuation">:</span> <span class="token string">'Nicholas'</span><span class="token punctuation">,</span>
  age<span class="token punctuation">:</span> <span class="token number">29</span><span class="token punctuation">,</span>
  job<span class="token punctuation">:</span> <span class="token string">'Software Engineer'</span><span class="token punctuation">,</span>
  friends<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'Shelby'</span><span class="token punctuation">,</span> <span class="token string">'Court'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token function-variable function">sayName</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

p1<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'Van'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'Shelby, Court, Van'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'Shelby, Court, Van'，但实际开发中，我们希望的是只改变p1中的friends属性，而p2的friends不应改变</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>friends <span class="token operator">===</span> p2<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p>这个问题正是我们很少看到有人单独使用原型模式的原因所在。</p> <h3 id="_6-2-4-组合使用构造函数模式和原型模式"><a href="#_6-2-4-组合使用构造函数模式和原型模式" aria-hidden="true" class="header-anchor">#</a> 6.2.4 组合使用构造函数模式和原型模式</h3> <p>创建自定义类型的最常见方式，就是组合使用构造函数模式和原型模式。</p> <ul><li>构造函数模式用于定义实例属性；</li> <li>原型模式用于定义方法和共享的属性；</li> <li>每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度的节省了内存；</li> <li>此外，这种混合模式还支持向构造函数传递参数；</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>friends <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Shelby'</span><span class="token punctuation">,</span> <span class="token string">'Court'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  constructor<span class="token punctuation">:</span> Person<span class="token punctuation">,</span>
  <span class="token function-variable function">sayName</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Nicholas'</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token string">'Software Engineer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Greg'</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">,</span> <span class="token string">'Doctor'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

p1<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'Van'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'Shelby, Court, Van'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'Shelby, Court'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>friends <span class="token operator">===</span> p2<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>sayName <span class="token operator">===</span> p2<span class="token punctuation">.</span>sayName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p>这种混合模式是目前在ECMAScript中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说是默认模式了。</p> <h3 id="_6-2-5-动态原型模式"><a href="#_6-2-5-动态原型模式" aria-hidden="true" class="header-anchor">#</a> 6.2.5 动态原型模式</h3> <p>动态原型模式的将所有信息都封装在构造函数中，而通过在构造函数中初始化原型（仅在有必要情况下），又保持了同时视同构造函数和原型的优点。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>
  
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span><span class="token punctuation">.</span>sayName <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 只有在初次调用构造函数时才会执行，之后原型已经初始化完了就不需要再作什么修改了。</span>
      <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Nicholas'</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token string">'Software Engineer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p1<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这个模式创建的对象，还可以使用 instanceof 操作符确定它的类型。</p> <h3 id="_6-2-6-寄生构造函数模式"><a href="#_6-2-6-寄生构造函数模式" aria-hidden="true" class="header-anchor">#</a> 6.2.6 寄生构造函数模式</h3> <p>在前几种模式都不适用的情况下，可以使用寄生构造函数模式。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age <span class="token punctuation">,</span>job</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  obj<span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  obj<span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  obj<span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>
  obj<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  
  <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Nicholas'</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token string">'Software Engineer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p1<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'Nicholas'</span>
</code></pre></div><p>这个模式可以在特殊的情况下用来为对象创建构造函数。加入我们想创建一个具有额外方法的特殊数组，但是由于不能直接修改 Array 构造函数，因此可以使用这种模式：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">SpecialArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> values <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  values<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>values<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  values<span class="token punctuation">.</span><span class="token function-variable function">toPipedString</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'|'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  
  <span class="token keyword">return</span> values<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> colors <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SpecialArray</span><span class="token punctuation">(</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>colors<span class="token punctuation">.</span><span class="token function">toPipedString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'red|blue|green'</span>
</code></pre></div><p>关于寄生构造函数模式，需要说明：返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象和在构造函数外部创建的对象没什么不一样。因此不能依赖 instanceof 操作符来确定对象类型。</p> <p>一般其他模式可用的情况下，不推荐使用寄生构造函数模式。</p> <h3 id="_6-2-7-稳妥构造函数模式"><a href="#_6-2-7-稳妥构造函数模式" aria-hidden="true" class="header-anchor">#</a> 6.2.7 稳妥构造函数模式</h3> <p>稳妥对象，是由 道格拉·斯克罗克福德（Douglas Crockford）发明的。所谓稳妥对象：指的是没有公共属性，而且其方法也不引用this对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用this和new），或者在防止数据被其他应用程序（如Mashup程序）改动时使用。</p> <p>稳妥构造函数遵循与寄生构造函数类似的形式，但有两点不同：</p> <ul><li>新创建对象的实例方法不引用this；</li> <li>不使用new操作符调用构造函数；</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age <span class="token punctuation">,</span>job</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  obj<span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  obj<span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  obj<span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>
  obj<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  
  <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token string">'Nicholas'</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token string">'Software Engineer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p1<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'Nicholas'</span>
</code></pre></div><h2 id="_6-3-继承"><a href="#_6-3-继承" aria-hidden="true" class="header-anchor">#</a> 6.3 继承</h2> <p>许多OO语言都支持两种继承方式： <strong>接口继承</strong> 和 <strong>实现继承</strong>。<br>
接口继承只继承方法签名，而实现继承则继承实际的方法。<br>
由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而实现继承主要依靠原型链来实现。</p> <h3 id="_6-3-1-原型链"><a href="#_6-3-1-原型链" aria-hidden="true" class="header-anchor">#</a> 6.3.1 原型链</h3> <p>什么是原型链：假如我们让原型对象等于另一个类型的实例，此时原型对象将包含一个指向另一个原型的指针，同时另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条，所谓的原型链。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>property<span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getSuperValue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>property<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subProperty <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

<span class="token comment">// 继承了 SuperType 实例</span>
<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getSubValue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subProperty<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span><span class="token function">getSuperValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>constructor <span class="token operator">===</span> SuperType<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true，这是因为原来SubType.prototype 中的 constructor 被重写指向了 SuperType。</span>
</code></pre></div><p>继承实现的本质就是重写原型对象，代之以一个新类型的实例。</p> <h4 id="_6-3-1-1-默认的原型"><a href="#_6-3-1-1-默认的原型" aria-hidden="true" class="header-anchor">#</a> 6.3.1.1 默认的原型</h4> <p>所有引用类型默认都继承了 Object，而这个继承也是通过原型链实现的。记住：所有函数的默认原型都是 Object 的实例，因此默认原型都会包含一个内部指针指向 Object.prototype，这也正是所有自定义类型都会继承 toString()、valueOf() 等默认方法的根本原因。</p> <p>总之，SubType 继承了 SuperType，而SuperType 继承了 Object，当调用 instance.toString() 方法实际上就是调用了保存在 Object.prototype 中的那个方法。</p> <h4 id="_6-3-1-2-确定原型和实例的关系"><a href="#_6-3-1-2-确定原型和实例的关系" aria-hidden="true" class="header-anchor">#</a> 6.3.1.2 确定原型和实例的关系</h4> <p>可以使用两种方式来确定原型和实例之间关系：</p> <ul><li>instanceof 操作符，只要拿这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回 true：</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance <span class="token keyword">instanceof</span> <span class="token class-name">SuperType</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance <span class="token keyword">instanceof</span> <span class="token class-name">SubType</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// true</span>
</code></pre></div><p>由于原型链的关系，我们可以说是 instance 是 Object 、 SuperType 或 SubType 中任何一类型的实例</p> <ul><li>isPrototypeOf() 方法，同样也是只要原型链中出现过的原型，都可以说是该原型链派生的实例的原型，因此结果也会返回 true：</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// true</span>
</code></pre></div><h4 id="_6-3-1-3-谨慎地定义方法"><a href="#_6-3-1-3-谨慎地定义方法" aria-hidden="true" class="header-anchor">#</a> 6.3.1.3 谨慎地定义方法</h4> <p>子类型有时候需要覆盖超类型中的某个方法，或者需要添加超类型中不存在的某个方法，这时切记： <strong>给原型添加放的代码一定一定一定要放在替换原型的语句之后！！！</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>property<span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getSuperValue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>property<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subProperty <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

<span class="token comment">// 继承了 SuperType 实例</span>
<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 添加新方法</span>
<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getSubValue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subProperty<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 重写超类型中的方法</span>
<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getSuperValue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span><span class="token function">getSuperValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre></div><p>另一点需要注意的是， <strong>在通过原型链实现继承时，不能使用对象字面量创建原型方法！！！</strong>，因为这样就会重写原型链：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>property<span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getSuperValue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>property<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subProperty <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 继承了 SuperType 实例</span>
<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 添加新方法</span>
<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">getSubValue</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subProperty<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">getSuperValue</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span><span class="token function">getSuperValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error</span>
</code></pre></div><h4 id="_6-3-1-4-原型链的问题"><a href="#_6-3-1-4-原型链的问题" aria-hidden="true" class="header-anchor">#</a> 6.3.1.4 原型链的问题</h4> <ul><li>主要问题来自包含引用类型的原型。</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token string">'blue'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
instance1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'black'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'red, blue, green, black'</span>

<span class="token keyword">let</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'red, blue, green, black'</span>
</code></pre></div><p>按照之前了解的知识，应该是 instance1 和 instance2 两个实例分别有自己的数组 colors 属性，即使 SubType.prototype 变成了 SuperType 的一个实例，它也拥有与一个它自己的 colors 属性，但是结果却是 SubType 的所有实例都会共享这一个 colors 属性。</p> <ul><li>在创建子类型的实例时，不能向超类型的构造函数中传递参数。就是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。</li></ul> <p>综上所述两个问题，实践中我们很少会单独使用原型链。</p> <h3 id="_6-3-2-借用构造函数"><a href="#_6-3-2-借用构造函数" aria-hidden="true" class="header-anchor">#</a> 6.3.2 借用构造函数</h3> <p>为解决原型中包含引用类型值所带来的问题，开发人员使用一种叫做 <strong>借用构造函数</strong> 的技术（有时候也叫做伪造对象或经典继承）。即：在子类型构造函数的内部调用超类型构造函数。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
instance1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'black'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'red, blue, green, black'</span>

<span class="token keyword">let</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'red, blue, green'</span>
</code></pre></div><p>通过 call() 方法（或 apply() 方法），在新创建的 SubType 实例的环境下调用了 SuperType 构造函数。这样就会在新 SubType 对象上 执行 SuperType() 函数中定义的所有初始化对象，最终 SubType 的每个实例就会都具有自己的 colors 属性副本。</p> <h4 id="_6-3-2-1-传递参数"><a href="#_6-3-2-1-传递参数" aria-hidden="true" class="header-anchor">#</a> 6.3.2.1 传递参数</h4> <p>相对于原型链而言，借用构造函数有一大优势，就是可以在子类型构造函数中向超类型构造函数传递参数。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token parameter">age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">'Nicholas'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token number">29</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'Nicholas'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 29</span>
</code></pre></div><h4 id="_6-3-2-2-借用构造函数的问题"><a href="#_6-3-2-2-借用构造函数的问题" aria-hidden="true" class="header-anchor">#</a> 6.3.2.2 借用构造函数的问题</h4> <p>如果仅仅是借用构造函数，那么就无法避险构造函数模式存在的问题——方法都在构造函数中定义，因此无法函数复用了。而且在超类型的原型中定义的方法，对于子类型而言是不可见的，结果所有类型都只能使用构造函数模式。因此，借用构造函数的方式也是很少单独使用的。</p> <h3 id="_6-3-3-组合继承"><a href="#_6-3-3-组合继承" aria-hidden="true" class="header-anchor">#</a> 6.3.3 组合继承</h3> <p>有时候也叫伪经典继承，指的是将原型链和借用构造函数的技术组合到一块。</p> <p>其原理为：使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> SubType<span class="token punctuation">;</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayAge</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token string">'Nicholas'</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
instance1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'black'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 'red, blue, green, black'</span>
instance1<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 'Nicholas'</span>
instance1<span class="token punctuation">.</span><span class="token function">sayAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 29</span>

<span class="token keyword">let</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token string">'Greg'</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 'red, blue, green'</span>
instance2<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 'Greg'</span>
instance2<span class="token punctuation">.</span><span class="token function">sayAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 27</span>
</code></pre></div><p>组合继承避免了原型链和借用构造函数的缺陷，而且， instanceof 和 isPrototypeOf() 也能够用于识别基于组合继承创建的对象。</p> <h3 id="_6-3-4-原型式继承"><a href="#_6-3-4-原型式继承" aria-hidden="true" class="header-anchor">#</a> 6.3.4 原型式继承</h3> <p>道格拉斯·克罗克福德在2006年写的题为 Prototype Inheritance in JavaScript 中介绍了一种实现继承的方法，该方法并没有严格意义上的构造函数么事借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。</p> <p>object() 本质上讲就是对传入其中的对象进行了一次浅拷贝。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">object</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>       <span class="token comment">// 临时性构造函数</span>
  <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> obj<span class="token punctuation">;</span>    <span class="token comment">// 将传入的对象作为临时构造函数的原型</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 返回一个临时构造函数的实例</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token string">'Nicholas'</span><span class="token punctuation">,</span>
  friends<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'Shelby'</span><span class="token punctuation">,</span> <span class="token string">'Court'</span><span class="token punctuation">,</span> <span class="token string">'Van'</span><span class="token punctuation">]</span>  
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> anotherPerson <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
anotherPerson<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Greg'</span><span class="token punctuation">;</span>
anotherPerson<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'Rob'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> yetAnotherPerson <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
yetAnotherPerson<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Linda'</span><span class="token punctuation">;</span>
yetAnotherPerson<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'Barbie'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'Shelby, Court, Van, Rob, Barbie'</span>
</code></pre></div><p>ES5中新增了 <strong>Object.create()</strong> 方法规范花了原型式继承。该方法接收两个参数：新对象原型的对象 和 （可选）为新对象定义额外属性的对象。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token string">'Nicholas'</span><span class="token punctuation">,</span>
  friends<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'Shelby'</span><span class="token punctuation">,</span> <span class="token string">'Court'</span><span class="token punctuation">,</span> <span class="token string">'Van'</span><span class="token punctuation">]</span>  
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> anotherPerson <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这里写法同 Object.defineProperties() 方法的第二个参数</span>
    name<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        value<span class="token punctuation">:</span> <span class="token string">'Greg'</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
anotherPerson<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'Rob'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> yetAnotherPerson <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
yetAnotherPerson<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Linda'</span><span class="token punctuation">;</span>
yetAnotherPerson<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'Barbie'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'Shelby, Court, Van, Rob, Barbie'</span>
</code></pre></div><h3 id="_6-3-5-寄生式继承"><a href="#_6-3-5-寄生式继承" aria-hidden="true" class="header-anchor">#</a> 6.3.5 寄生式继承</h3> <p>寄生式继承的思路与寄生构造函数和工厂函数类似，即创建一个仅用于封装继承过程的函数。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">createAnother</span><span class="token punctuation">(</span><span class="token parameter">original</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> clone <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 通过调用函数创建一个新对象</span>
  clone<span class="token punctuation">.</span><span class="token function-variable function">sayHi</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 以某种方式来增强这个对象</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Hi'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  
  <span class="token keyword">return</span> clone<span class="token punctuation">;</span>                     <span class="token comment">// 返回这个对象</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token string">'Nicholas'</span><span class="token punctuation">,</span>
  friends<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'Shelby'</span><span class="token punctuation">,</span> <span class="token string">'Court'</span><span class="token punctuation">,</span> <span class="token string">'Van'</span><span class="token punctuation">]</span>  
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> anotherPerson <span class="token operator">=</span> <span class="token function">createAnother</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
anotherPerson<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'Hi'</span>
</code></pre></div><h3 id="_6-3-6-寄生组合式继承"><a href="#_6-3-6-寄生组合式继承" aria-hidden="true" class="header-anchor">#</a> 6.3.6 寄生组合式继承</h3> <p>组合继承虽然是常用继承模式，但是也有不足，都会调用两次超类型构造函数：一次在创建子类型原型的时候，另一次是在子类型构造函数内部。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 第二次调用 SuperType()</span>
  
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 第一次调用 SuperType()</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> SubType<span class="token punctuation">;</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayAge</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>而寄生组合式继承，就是通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。基本思路：不必为了指定子类型的原型而调用超类型的构造函数，我们需要的只是超类型的一个副本。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">inheritPrototype</span><span class="token punctuation">(</span><span class="token parameter">subType<span class="token punctuation">,</span> superType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> prototype <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>superType<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 创建对象，创建超类型原型的一个副本。</span>
  prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> subType<span class="token punctuation">;</span>              <span class="token comment">// 增强对象，为副本添加 constructor 属性，从而弥补因重写原型而失去的默认的 constructor 属性。</span>
  subType<span class="token punctuation">.</span>prototype <span class="token operator">=</span> prototype<span class="token punctuation">;</span>                <span class="token comment">// 指定对象，将新创建的副本复制给子类型的原型。</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 第二次调用 SuperType()</span>
  
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">inheritPrototype</span><span class="token punctuation">(</span>SubType<span class="token punctuation">,</span> SuperType<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayAge</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>此处高效体现在于它只调用了一次 SuperType 构造函数，并且因此避免了在 SubType.prototype 上面创建不必要的、多余的属性，同时原型链还能保持不变。除此之外， instanceof 和 isPrototypeOf() 还能正常使用。</p> <p>目前，寄生组合式继承 是引用类型最理想的继承范式。</p> <h2 id="_6-4-总结-faq"><a href="#_6-4-总结-faq" aria-hidden="true" class="header-anchor">#</a> 6.4 总结 &amp; FAQ</h2> <h3 id="_6-4-1-总结"><a href="#_6-4-1-总结" aria-hidden="true" class="header-anchor">#</a> 6.4.1 总结</h3> <ol><li>ECMAScript支持面向对象编程，但是不支持类或者接口。在没有类的情况下，我们可以采用以下模式创建对象：</li></ol> <ul><li>工厂模式：使用简单函数创建对象，为对象添加属性和方法，然后返回对象。</li> <li>构造函数模式：可以自定义引用类型，使用 new 操作符新建实例化对象。但是其每个成员都无法得到复用，包括函数。</li> <li>原型模式：使用构造函数的 prototype 属性来指定那些应该共享的属性和方法。<strong>组合使用构造函数模式和原型模式</strong> ，使用构造函数定义实例属性，使用原型定义共享的属性和方法。</li></ul> <ol start="2"><li>JavaScript通过 原型链 实现继承。原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的。原型链的问题在于对象实例共享所有继承的属性和方法，而通过 借用构造函数 来解决：在子类型构造函数的内部调用超类型构造函数。除此之外，还存在以下可供选择的继承模式：</li></ol> <ul><li>原型式继承：其本质是执行对给定对象的浅复制。</li> <li>寄生式继承：与原型式继承很相似，基于某个对象或某些信息创建一个对象，然后增强对象，最后返回对象。</li> <li>寄生组合式继承：为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问题，集寄生式继承和组合继承的优点，是目前实现类型继承的最有效方式。</li></ul> <ol start="3"><li>原型、构造函数和实例的关系：</li></ol> <ul><li>实例.<strong>proto</strong> === 原型</li> <li>原型.constructor === 构造函数</li> <li>构造函数.prototype === 原型</li> <li>实例.constructor === 构造函数
<img src="https://user-gold-cdn.xitu.io/2019/2/14/168e9d9b940c4c6f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="关系图"></li></ul> <h3 id="_6-4-2-faq"><a href="#_6-4-2-faq" aria-hidden="true" class="header-anchor">#</a> 6.4.2 FAQ</h3> <ol><li>实例化对象时，new操作符都干了些什么事？</li> <li>6.3.4原型式继承中 object 函数里面执行下来为什么是浅复制？</li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/resource/javascript-advanced-programming/05/" class="prev">
          5 引用类型
        </a></span> <span class="next"><a href="/resource/javascript-advanced-programming/07/">
          7 函数表达式
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.e304fcc0.js" defer></script><script src="/assets/js/2.288486c1.js" defer></script><script src="/assets/js/14.e911768a.js" defer></script>
  </body>
</html>
